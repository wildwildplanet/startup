FetchLogic for Startup Cards

1. Pagination Setup
   • PAGE_SIZE defines how many cards to fetch per batch (e.g. 8).
   • pageNum indicates which batch to load: start = pageNum * PAGE_SIZE, end = start + PAGE_SIZE - 1.

2. Supabase Query
   • Uses `supabase.from('startups').select('*')` (no `{count: 'exact'}`) to reduce payload and improve performance.
   • Sorted by `created_at desc` so newest startups appear first.
   • `.range(start, end)` pages the results server-side.

3. Data Normalization
   • Each DB row is mapped to our in-memory `Startup` interface:
     – Fallback defaults for missing fields (e.g. askamount, valuation, stage).
     – Parsing nested JSON (`funding_allocation`, `financials`) when stored as strings.
     – Generating a fallback logo URL via `generateLogoUrl()` if none is provided.

4. Loading Flags & Guards
   • `loading` and `loadingMore` state track in-progress fetches.
   • Guard clauses prevent redundant calls:
     – If first page is already loading, skip new `fetchStartups(0)`.
     – If loading additional pages, skip overlapping calls.

5. State Updates
   • **First page (pageNum=0):**
     – `setStartups(enhancedData)` replaces old deck.
     – `setCurrentIndex(0)` and `setCurrentStartup(enhancedData[0])` reset the view.
   • **Subsequent pages:**
     – `setStartups(prev => [...prev, ...enhancedData])` appends cards to existing deck.
   • `setPage(pageNum)` and `setHasMore(data.length===PAGE_SIZE)` update pagination metadata.

6. Triggering Fetches
   • **Screen Focus:** `useIsFocused()` invokes `fetchStartups(0)` whenever Home regains focus.
   • **Prefetching Next Page:**
     – A `useEffect` watches `currentIndex` and, when user is 2 cards away from the end, calls `InteractionManager.runAfterInteractions(() => fetchStartups(page+1))`.
     – This defers fetch until UI is idle, ensuring smooth interactions.

7. Performance & Scalability
   • No client-side `.sort()` or randomization to avoid CPU overhead.
   • Dropping count queries reduces payload and indexing cost in Supabase.
   • Using `runAfterInteractions` ensures prefetch does not compete with gesture animations or rendering.
   • Wrapping `fetchStartups` in `useCallback` stabilizes the function reference and avoids re-creating effects.

8. Best Practices
   • Keys: Use unique `id` as React list key (`keyExtractor`).
   • Error handling: Log and gracefully stop further fetches on any error.
   • Future: Consider React Query’s `useInfiniteQuery` for caching, retries, and built-in lifecycle management.
